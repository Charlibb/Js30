<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JS Reference VS Copy</title>
  </head>
  <body>
    <script>
      // Differenc ebetwen reference and copy

      // start with strings, numbers and booleans
      let age = 100;
      let age2 = 100;
      console.log(age, age2); // output: 100, 100
      age = 200; // not using let, just assigning new value to age
      console.log(age, age2); // output 200, 100

      // Value of "age" goes into the variable at the same time

      let name = "charli";
      let name2 = name;

      console.log(name, name2); // charli , charli
      name = "nono";
      console.log(name, name2); // nono, charli

      let numberA = 555;
      let numberB = numberA;
      console.log(numberA, numberB); // 555, 555
      numberA = 0;
      console.log(numberA, numberB); // 0, 555

      // Let's say we have an array
      let players = ["Wes", "Sarah", "Ryan", "Poppy"];
      let teams = players;
      console.log("players are: ", players, "and teams are", teams);
      // (4)['Wes', 'Sarah', 'Ryan', 'Poppy'] and teams are (4)['Wes', 'Sarah', 'Ryan', 'Poppy']

      teams[3] = "Charli"; // it is a reference to original array "players"!!
      console.log(
        "After teams[3] = Charli; This is  the Result for teams array: ",
        teams
      );
      // ['Wes', 'Sarah', 'Ryan', 'Charli']
      console.log(
        "After teams[3] = Charli; This is  the Result:for players array ",
        players
      );
      // ['Wes', 'Sarah', 'Ryan', 'Charli']

      // We have the same output : ['Wes', 'Sarah', 'Ryan', 'Poppy']; BOTH ARRAY HAVE MUTATED

      /*  players = ['john'];  */ // players are:  ['john']  and teams are (4)Â ['Wes', 'Sarah', 'Ryan', 'Poppy']
      console.log("players are: ", players, " and teams are", teams);

      /* IF YOU UPDATE AN ARRAY IT WILL ALWAYS REFERENCE BACK */

      // and we want to make a copy of it.

      // You might think we can just do something like this:

      // however what happens when we update that array?

      // now here is the problem!

      // oh no - we have edited the original array too!

      // Why? It's because that is an array reference, not an array copy. They both point to the same array!

      // So, how do we fix this? We take a copy instead!

      /* ARRAY COPYING:
      ES6 spread operator: squad2 = [...squad];
      Slice: squad2 = squad.slice();
      Concatenate into empty array: squad2 = [].concat(squad);
      From an array: squad2 = Array.from(squad);
      */

      // one way
      console.clear();
      const  team2 = players.slice();
      console.log("this is slice copy of an array: ");
      console.log(team2);





      // or create a new array and concat the old one in
      console.log("this is concat method to  copy an array: ")
      team3= [].concat(players)
      console.log(team3);
        console.log(players) 

      // or use the new ES6 Spread
      team4 = [...players]
      console.log("this is spread method ", team4)

      const team5 = Array.from(players);
      console.log(teams)

      
 
      // now when we update it, the original one isn't changed
     console.log(teams)
      // The same thing goes for objects, let's say we have a person object

      // with Objects
      const person = {
        name: "Wes Bos",
        age: 80,
      };

      // and think we make a copy:


      // how do we take a copy instead?
      person2 = Object.assign({},person,{ number:55, age:16});
      console.log(person2); // {name: 'Wes Bos', age: 16, number: 55}
      console.log(person); //  {name: 'Wes Bos', age: 80}

      // We will hopefully soon see the object ...spread

      // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

      const dev2 =  JSON.parse(JSON.stringify(wes));
       // stringify turn  obj into string and parse changes into array
    
    </script>
  </body>
</html>
